{"version":3,"file":"useBotActivity-c7497cbd.js","sources":["../../src/hooks/useBotActivity.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { supabase } from '../lib/supabase';\n\nexport interface BotActivityLog {\n  id: string;\n  botId: string;\n  timestamp: string;\n  level: 'info' | 'warning' | 'error' | 'success';\n  category: 'market' | 'trade' | 'strategy' | 'system' | 'error';\n  message: string;\n  details?: any;\n  data?: any;\n}\n\nexport interface BotActivity {\n  botId: string;\n  botName: string;\n  status: string;\n  lastActivity: string;\n  lastExecutionTime?: string | null;\n  logs: BotActivityLog[];\n  isActive: boolean;\n  currentAction?: string;\n  waitingFor?: string;\n  executionState?: 'executing' | 'analyzing' | 'waiting' | 'idle' | 'error';\n  errorCount: number;\n  successCount: number;\n}\n\nexport function useBotActivity(bots?: any[]) {\n  const [activities, setActivities] = useState<BotActivity[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const addLog = async (botId: string, log: Omit<BotActivityLog, 'id' | 'timestamp'>) => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('No active session');\n\n      const newLog = {\n        bot_id: botId,\n        level: log.level,\n        category: log.category,\n        message: log.message,\n        details: log.details,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Save to database\n      const { error } = await supabase\n        .from('bot_activity_logs')\n        .insert(newLog);\n\n      if (error) {\n        console.error('Error saving log to database:', error);\n        // Fallback to localStorage\n        const existingLogs = JSON.parse(localStorage.getItem(`bot_logs_${botId}`) || '[]');\n        const updatedLogs = [...existingLogs, { ...log, id: Date.now().toString(), botId, timestamp: new Date().toISOString() }];\n        localStorage.setItem(`bot_logs_${botId}`, JSON.stringify(updatedLogs));\n      }\n\n      // Update activities state\n      setActivities(prev => prev.map(activity => \n        activity.botId === botId \n          ? {\n              ...activity,\n              logs: [{ ...log, id: Date.now().toString(), botId, timestamp: new Date().toISOString() }, ...activity.logs.slice(0, 49)],\n              lastActivity: new Date().toISOString(),\n              errorCount: log.level === 'error' ? activity.errorCount + 1 : activity.errorCount,\n              successCount: log.level === 'success' ? activity.successCount + 1 : activity.successCount,\n            }\n          : activity\n      ));\n\n      return newLog;\n    } catch (err) {\n      console.error('Error adding bot log:', err);\n      throw err;\n    }\n  };\n\n  const fetchBotLogs = async (botId: string) => {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('No active session');\n\n      const { data: logs, error } = await supabase\n        .from('bot_activity_logs')\n        .select('*')\n        .eq('bot_id', botId)\n        .order('timestamp', { ascending: false })\n        .limit(100);\n\n      if (error) {\n        console.error('Error fetching bot logs from database:', error);\n        // Fallback to localStorage if database fails\n        const fallbackLogs = JSON.parse(localStorage.getItem(`bot_logs_${botId}`) || '[]');\n        return fallbackLogs.sort((a: BotActivityLog, b: BotActivityLog) => \n          new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n        );\n      }\n\n      return logs || [];\n    } catch (err) {\n      console.error('Error fetching bot logs:', err);\n      // Fallback to localStorage\n      const fallbackLogs = JSON.parse(localStorage.getItem(`bot_logs_${botId}`) || '[]');\n      return fallbackLogs.sort((a: BotActivityLog, b: BotActivityLog) => \n        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n      );\n    }\n  };\n\n  // Analyze logs to determine current activity state\n  const analyzeActivityState = (logs: BotActivityLog[], botStatus: string): { currentAction: string; waitingFor?: string; executionState: 'executing' | 'analyzing' | 'waiting' | 'idle' | 'error' } => {\n    if (botStatus !== 'running') {\n      return {\n        currentAction: `Bot is ${botStatus}`,\n        executionState: 'idle'\n      };\n    }\n\n    if (logs.length === 0) {\n      return {\n        currentAction: 'Initializing...',\n        waitingFor: 'First execution',\n        executionState: 'waiting'\n      };\n    }\n\n    const latestLog = logs[0];\n    const logTime = new Date(latestLog.timestamp).getTime();\n    const now = Date.now();\n    const timeSinceLastLog = now - logTime;\n    const fiveMinutesAgo = 5 * 60 * 1000;\n    const oneMinuteAgo = 60 * 1000;\n\n    // Check for recent errors\n    const recentErrors = logs.filter(log => \n      log.level === 'error' && \n      (now - new Date(log.timestamp).getTime()) < fiveMinutesAgo\n    );\n    if (recentErrors.length > 0) {\n      return {\n        currentAction: `Error: ${recentErrors[0].message}`,\n        executionState: 'error'\n      };\n    }\n\n    // Analyze latest log message to infer state\n    const message = latestLog.message.toLowerCase();\n    \n    // Execution states based on log messages\n    if (message.includes('executing') || message.includes('execution') || message.includes('starting execution')) {\n      return {\n        currentAction: latestLog.message,\n        executionState: 'executing'\n      };\n    }\n    \n    if (message.includes('analyzing') || message.includes('analysis') || message.includes('market data') || message.includes('rsi') || message.includes('adx')) {\n      return {\n        currentAction: latestLog.message,\n        executionState: 'analyzing'\n      };\n    }\n    \n    if (message.includes('trade') && (message.includes('placed') || message.includes('executed') || message.includes('opened') || message.includes('closed'))) {\n      return {\n        currentAction: latestLog.message,\n        executionState: 'executing'\n      };\n    }\n    \n    if (message.includes('waiting') || message.includes('monitoring') || message.includes('syncing time')) {\n      return {\n        currentAction: latestLog.message,\n        waitingFor: message.includes('waiting') ? 'Market signal' : 'Next execution cycle',\n        executionState: 'waiting'\n      };\n    }\n\n    // Check time since last activity\n    if (timeSinceLastLog > fiveMinutesAgo) {\n      return {\n        currentAction: `Last activity: ${formatTimeAgo(timeSinceLastLog)}`,\n        waitingFor: 'Next cron execution',\n        executionState: 'waiting'\n      };\n    }\n\n    if (timeSinceLastLog < oneMinuteAgo) {\n      // Very recent activity\n      return {\n        currentAction: latestLog.message,\n        executionState: latestLog.category === 'trade' ? 'executing' : 'analyzing'\n      };\n    }\n\n    // Default based on category\n    const executionStateMap: Record<string, 'executing' | 'analyzing' | 'waiting' | 'idle'> = {\n      'trade': 'executing',\n      'market': 'analyzing',\n      'strategy': 'analyzing',\n      'system': 'waiting',\n      'error': 'error' as any\n    };\n\n    return {\n      currentAction: latestLog.message,\n      waitingFor: latestLog.category === 'market' ? 'Market conditions' : undefined,\n      executionState: executionStateMap[latestLog.category] || 'waiting'\n    };\n  };\n\n  const formatTimeAgo = (ms: number): string => {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n    \n    if (days > 0) return `${days}d ago`;\n    if (hours > 0) return `${hours}h ago`;\n    if (minutes > 0) return `${minutes}m ago`;\n    return `${seconds}s ago`;\n  };\n\n  const fetchAllActivities = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // Use passed bots or return empty if no bots provided\n      if (!bots || bots.length === 0) {\n        setActivities([]);\n        return;\n      }\n\n      // Fetch logs for each bot\n      const activities: BotActivity[] = await Promise.all(\n        bots.map(async (bot: any) => {\n          const logs = await fetchBotLogs(bot.id);\n          const errorCount = logs.filter((log: BotActivityLog) => log.level === 'error').length;\n          const successCount = logs.filter((log: BotActivityLog) => log.level === 'success').length;\n          \n          // Analyze activity state\n          const activityState = analyzeActivityState(logs, bot.status);\n          \n          // Get last execution time\n          const lastTradeLog = logs.find(log => log.category === 'trade');\n          const lastExecutionTime = lastTradeLog ? lastTradeLog.timestamp : null;\n          \n          return {\n            botId: bot.id,\n            botName: bot.name,\n            status: bot.status,\n            lastActivity: logs.length > 0 ? logs[0].timestamp : bot.createdAt,\n            lastExecutionTime: lastExecutionTime,\n            logs: logs.slice(0, 50), // Keep only last 50 logs\n            isActive: bot.status === 'running',\n            currentAction: activityState.currentAction,\n            waitingFor: activityState.waitingFor,\n            executionState: activityState.executionState,\n            errorCount,\n            successCount,\n          };\n        })\n      );\n\n      setActivities(activities);\n    } catch (err) {\n      console.error('Error fetching bot activities:', err);\n      setError(err instanceof Error ? err.message : 'Failed to fetch activities');\n      // Don't set empty activities on error, keep existing ones\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const clearBotLogs = async (botId: string) => {\n    try {\n      localStorage.removeItem(`bot_logs_${botId}`);\n      await fetchAllActivities();\n    } catch (err) {\n      console.error('Error clearing bot logs:', err);\n    }\n  };\n\n  const simulateBotActivity = async (botId: string) => {\n    const activities = [\n      { level: 'info' as const, category: 'system' as const, message: 'Bot initialized successfully' },\n      { level: 'info' as const, category: 'market' as const, message: 'Analyzing market conditions...' },\n      { level: 'info' as const, category: 'strategy' as const, message: 'RSI: 45, ADX: 28 - Market trending' },\n      { level: 'success' as const, category: 'trade' as const, message: 'Long position opened at $45,250' },\n      { level: 'info' as const, category: 'market' as const, message: 'Monitoring position...' },\n      { level: 'warning' as const, category: 'market' as const, message: 'Price approaching stop loss' },\n      { level: 'success' as const, category: 'trade' as const, message: 'Position closed with +2.5% profit' },\n    ];\n\n    for (const activity of activities) {\n      await addLog(botId, activity);\n      await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay\n    }\n  };\n\n  useEffect(() => {\n    fetchAllActivities();\n    \n    // Set up polling for real-time updates (every 10 seconds for more responsive UI)\n    const interval = setInterval(fetchAllActivities, 10000); // Update every 10 seconds\n    \n    return () => clearInterval(interval);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [bots]); // Depend on bots parameter - fetchAllActivities is stable\n\n  return {\n    activities,\n    loading,\n    error,\n    addLog,\n    fetchBotLogs,\n    clearBotLogs,\n    simulateBotActivity,\n    refetch: fetchAllActivities,\n  };\n}\n"],"names":["useBotActivity","bots","activities","setActivities","useState","loading","setLoading","error","setError","addLog","botId","log","user","supabase","newLog","updatedLogs","prev","activity","err","fetchBotLogs","logs","b","a","analyzeActivityState","botStatus","latestLog","logTime","now","timeSinceLastLog","fiveMinutesAgo","oneMinuteAgo","recentErrors","message","formatTimeAgo","executionStateMap","ms","seconds","minutes","hours","days","fetchAllActivities","bot","errorCount","successCount","activityState","lastTradeLog","lastExecutionTime","clearBotLogs","simulateBotActivity","resolve","useEffect","interval"],"mappings":"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"}